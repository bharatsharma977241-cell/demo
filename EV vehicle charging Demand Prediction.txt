import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.model_selection import GridSearchCV
import warnings
warnings.filterwarnings('ignore')

class EVChargingDemandPredictor:
    def __init__(self):
        self.models = {}
        self.scaler = StandardScaler()
        self.label_encoders = {}
        self.feature_columns = []
        self.target_column = 'charging_demand_kw'

    def generate_synthetic_data(self, n_samples=10000):
        """Generate synthetic EV charging demand data"""
        np.random.seed(42)

        # Date range
        start_date = datetime(2023, 1, 1)
        dates = [start_date + timedelta(hours=i) for i in range(n_samples)]

        data = []
        for i, date in enumerate(dates):
            # Time-based features
            hour = date.hour
            day_of_week = date.weekday()  # 0=Monday, 6=Sunday
            month = date.month

            # Weather simulation (simplified)
            temp = 15 + 10 * np.sin(2 * np.pi * (month - 1) / 12) + np.random.normal(0, 5)
            weather_condition = np.random.choice(['clear', 'cloudy', 'rainy'],
                                               p=[0.6, 0.3, 0.1])

            # Location features
            location_type = np.random.choice(['urban', 'suburban', 'highway'],
                                           p=[0.5, 0.3, 0.2])
            num_charging_stations = np.random.randint(2, 20)

            # Economic factors
            electricity_price = 0.12 + np.random.normal(0, 0.02)

            # Base demand calculation with patterns
            base_demand = 50  # Base load

            # Hour of day pattern (peak during commute hours)
            if 7 <= hour <= 9 or 17 <= hour <= 19:  # Morning/evening rush
                hour_multiplier = 2.5 + np.random.normal(0, 0.3)
            elif 10 <= hour <= 16:  # Daytime
                hour_multiplier = 1.5 + np.random.normal(0, 0.2)
            elif 20 <= hour <= 23:  # Evening
                hour_multiplier = 1.8 + np.random.normal(0, 0.3)
            else:  # Night/early morning
                hour_multiplier = 0.3 + np.random.normal(0, 0.1)

            # Day of week pattern (higher on weekdays)
            if day_of_week < 5:  # Weekday
                day_multiplier = 1.2
            else:  # Weekend
                day_multiplier = 0.8

            # Location pattern
            location_multipliers = {'urban': 1.5, 'suburban': 1.0, 'highway': 1.3}
            location_multiplier = location_multipliers[location_type]

            # Weather impact
            weather_multipliers = {'clear': 1.0, 'cloudy': 0.95, 'rainy': 0.85}
            weather_multiplier = weather_multipliers[weather_condition]

            # Temperature impact (extreme temps increase demand due to HVAC)
            if temp < 0 or temp > 35:
                temp_multiplier = 1.2
            else:
                temp_multiplier = 1.0

            # Station availability impact
            station_multiplier = min(1.0 + (num_charging_stations - 5) * 0.05, 2.0)

            # Calculate final demand
            charging_demand = (base_demand * hour_multiplier * day_multiplier *
                             location_multiplier * weather_multiplier *
                             temp_multiplier * station_multiplier)

            # Add some noise
            charging_demand += np.random.normal(0, 5)
            charging_demand = max(0, charging_demand)  # Ensure non-negative

            data.append({
                'datetime': date,
                'hour': hour,
                'day_of_week': day_of_week,
                'month': month,
                'temperature': temp,
                'weather_condition': weather_condition,
                'location_type': location_type,
                'num_charging_stations': num_charging_stations,
                'electricity_price': electricity_price,
                'charging_demand_kw': charging_demand
            })

        return pd.DataFrame(data)

    def create_features(self, df):
        """Create additional features for modeling"""
        df = df.copy()

        # Time-based features
        df['hour_sin'] = np.sin(2 * np.pi * df['hour'] / 24)
        df['hour_cos'] = np.cos(2 * np.pi * df['hour'] / 24)
        df['day_sin'] = np.sin(2 * np.pi * df['day_of_week'] / 7)
        df['day_cos'] = np.cos(2 * np.pi * df['day_of_week'] / 7)
        df['month_sin'] = np.sin(2 * np.pi * df['month'] / 12)
        df['month_cos'] = np.cos(2 * np.pi * df['month'] / 12)

        # Categorical features
        df['is_weekend'] = (df['day_of_week'] >= 5).astype(int)
        df['is_rush_hour'] = ((df['hour'].between(7, 9)) |
                             (df['hour'].between(17, 19))).astype(int)
        df['is_peak_evening'] = df['hour'].between(20, 23).astype(int)

        # Temperature categories
        df['temp_category'] = pd.cut(df['temperature'],
                                   bins=[-float('inf'), 0, 10, 25, float('inf')],
                                   labels=['very_cold', 'cold', 'moderate', 'hot'])

        # Lagged features (simplified - in real scenario you'd have historical data)
        df['demand_lag_1h'] = df['charging_demand_kw'].shift(1)
        df['demand_lag_24h'] = df['charging_demand_kw'].shift(24)
        df['demand_rolling_mean_24h'] = df['charging_demand_kw'].rolling(24).mean()

        return df

    def preprocess_data(self, df):
        """Preprocess data for modeling"""
        # Create features
        df = self.create_features(df)

        # Handle missing values (from lagged features)
        df = df.dropna()

        # Encode categorical variables
        categorical_cols = ['weather_condition', 'location_type', 'temp_category']
        for col in categorical_cols:
            if col not in self.label_encoders:
                self.label_encoders[col] = LabelEncoder()
                df[col] = self.label_encoders[col].fit_transform(df[col])
            else:
                df[col] = self.label_encoders[col].transform(df[col])

        # Select features for modeling
        self.feature_columns = [
            'hour', 'day_of_week', 'month', 'temperature', 'weather_condition',
            'location_type', 'num_charging_stations', 'electricity_price',
            'hour_sin', 'hour_cos', 'day_sin', 'day_cos', 'month_sin', 'month_cos',
            'is_weekend', 'is_rush_hour', 'is_peak_evening', 'temp_category',
            'demand_lag_1h', 'demand_lag_24h', 'demand_rolling_mean_24h'
        ]

        X = df[self.feature_columns]
        y = df[self.target_column]

        return X, y

    def train_models(self, X_train, y_train):
        """Train multiple models"""
        # Scale features
        X_train_scaled = self.scaler.fit_transform(X_train)

        # Initialize models
        models = {
            'Linear Regression': LinearRegression(),
            'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
            'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, random_state=42)
        }

        # Train models
        for name, model in models.items():
            if name == 'Linear Regression':
                model.fit(X_train_scaled, y_train)
            else:
                model.fit(X_train, y_train)
            self.models[name] = model

        print("Models trained successfully!")

    def evaluate_models(self, X_test, y_test):
        """Evaluate all trained models"""
        results = {}
        X_test_scaled = self.scaler.transform(X_test)

        for name, model in self.models.items():
            if name == 'Linear Regression':
                y_pred = model.predict(X_test_scaled)
            else:
                y_pred = model.predict(X_test)

            mae = mean_absolute_error(y_test, y_pred)
            mse = mean_squared_error(y_test, y_pred)
            rmse = np.sqrt(mse)
            r2 = r2_score(y_test, y_pred)

            results[name] = {
                'MAE': mae,
                'MSE': mse,
                'RMSE': rmse,
                'R²': r2,
                'Predictions': y_pred
            }

        return results

    def plot_results(self, results, y_test):
        """Plot model comparison and predictions"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))

        # Model comparison
        metrics = ['MAE', 'RMSE', 'R²']
        model_names = list(results.keys())

        for i, metric in enumerate(metrics):
            if i < 3:
                ax = axes[0, 0] if i == 0 else (axes[0, 1] if i == 1 else axes[1, 0])
                values = [results[model][metric] for model in model_names]
                ax.bar(model_names, values)
                ax.set_title(f'{metric} Comparison')
                ax.tick_params(axis='x', rotation=45)

        # Actual vs Predicted for best model
        best_model = min(results.keys(), key=lambda x: results[x]['RMSE'])
        y_pred = results[best_model]['Predictions']

        axes[1, 1].scatter(y_test, y_pred, alpha=0.5)
        axes[1, 1].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
        axes[1, 1].set_xlabel('Actual Demand (kW)')
        axes[1, 1].set_ylabel('Predicted Demand (kW)')
        axes[1, 1].set_title(f'Actual vs Predicted - {best_model}')

        plt.tight_layout()
        plt.show()

    def predict_demand(self, input_data):
        """Make predictions on new data"""
        # Use the best performing model (Random Forest typically performs well)
        best_model_name = 'Random Forest'  # or determine programmatically
        model = self.models[best_model_name]

        if best_model_name == 'Linear Regression':
            prediction = model.predict(self.scaler.transform(input_data))
        else:
            prediction = model.predict(input_data)

        return prediction

    def feature_importance(self):
        """Show feature importance for tree-based models"""
        rf_model = self.models.get('Random Forest')
        if rf_model:
            importance = pd.DataFrame({
                'feature': self.feature_columns,
                'importance': rf_model.feature_importances_
            }).sort_values('importance', ascending=False)

            plt.figure(figsize=(10, 8))
            sns.barplot(data=importance.head(15), x='importance', y='feature')
            plt.title('Top 15 Feature Importances (Random Forest)')
            plt.show()

            return importance
        return None

# Example usage
def main():
    # Initialize predictor
    predictor = EVChargingDemandPredictor()

    # Generate synthetic data
    print("Generating synthetic EV charging demand data...")
    df = predictor.generate_synthetic_data(n_samples=8760)  # One year of hourly data

    print(f"Generated {len(df)} samples")
    print("\nData preview:")
    print(df.head())

    print("\nBasic statistics:")
    print(df.describe())

    # Preprocess data
    print("\nPreprocessing data...")
    X, y = predictor.preprocess_data(df)

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, shuffle=False  # Time series - no shuffling
    )

    # Train models
    print("\nTraining models...")
    predictor.train_models(X_train, y_train)

    # Evaluate models
    print("\nEvaluating models...")
    results = predictor.evaluate_models(X_test, y_test)

    # Print results
    print("\nModel Performance:")
    print("-" * 50)
    for model_name, metrics in results.items():
        print(f"{model_name}:")
        print(f"  MAE: {metrics['MAE']:.2f} kW")
        print(f"  RMSE: {metrics['RMSE']:.2f} kW")
        print(f"  R²: {metrics['R²']:.3f}")
        print()

    # Plot results
    predictor.plot_results(results, y_test)

    # Show feature importance
    print("\nFeature Importance Analysis:")
    importance_df = predictor.feature_importance()
    if importance_df is not None:
        print(importance_df.head(10))

    # Example prediction
    print("\nExample Prediction:")
    # Create a sample input (weekday, 8 AM, urban location, clear weather)
    sample_input = X_test.iloc[:1].copy()
    sample_input['hour'] = 8
    sample_input['is_rush_hour'] = 1
    sample_input['location_type'] = 2  # Encoded urban

    prediction = predictor.predict_demand(sample_input)
    print(f"Predicted demand for rush hour (8 AM, urban, clear weather): {prediction[0]:.1f} kW")

if __name__ == "__main__":
    main()